<?php
// Increase execution time limit (adjust as needed)
ini_set('max_execution_time', 900);  // 15 minutes
ini_set('memory_limit', '512M');     // Increase memory if needed

// Define helper functions first
function tableExists($pdo, $table) {
    $stmt = $pdo->prepare("SHOW TABLES LIKE ?");
    $stmt->execute([$table]);
    return $stmt->rowCount() > 0;
}

function columnExists($pdo, $table, $column) {
    if (!tableExists($pdo, $table)) return false;
    $stmt = $pdo->prepare("SHOW COLUMNS FROM $table LIKE ?");
    $stmt->execute([$column]);
    return $stmt->rowCount() > 0;
}

// Database connection
$host = "localhost";
$user = "root";
$pass = "";
$dbname = "l1j_remastered";

// Common ID column names in Lineage 1
$commonIdColumns = ['id', 'objid', 'char_id', 'npcid', 'item_id', 'account_id', 'clan_id', 
                    'castle_id', 'skill_id', 'quest_id', 'spawn_id', 'loc_id', 'polyid'];

// Start timing
$startTime = microtime(true);

try {
    $pdo = new PDO("mysql:host=$host;dbname=$dbname", $user, $pass);
    $pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
    
    // Start Markdown output
    $markdown = "# LineageDB Complete Relationship Analysis\n\n";
    $markdown .= "**Database:** $dbname\n";
    $markdown .= "**Generated:** 2025-03-01 22:41:20\n";
    $markdown .= "**Generated by:** WantedGaming\n\n";
    
    // Get all tables in the database
    $stmt = $pdo->query("SHOW TABLES");
    $allTables = $stmt->fetchAll(PDO::FETCH_COLUMN);
    $tableCount = count($allTables);
    
    $markdown .= "## Database Overview\n\n";
    $markdown .= "Found $tableCount tables in database.\n\n";
    
    // First, collect all table primary keys and their data types
    echo "<h2>Step 1/4: Analyzing table structures...</h2>";
    
    $tablePrimaryKeys = [];
    $tableColumns = [];
    $allRelationships = [];
    $totalColumnCount = 0;
    
    // More efficient - get all columns at once instead of per-table
    $columnQuery = "
        SELECT 
            TABLE_NAME, COLUMN_NAME, COLUMN_TYPE, 
            COLUMN_KEY, IS_NULLABLE, COLUMN_DEFAULT
        FROM 
            INFORMATION_SCHEMA.COLUMNS 
        WHERE 
            TABLE_SCHEMA = ?
        ORDER BY 
            TABLE_NAME, ORDINAL_POSITION
    ";
    
    $stmt = $pdo->prepare($columnQuery);
    $stmt->execute([$dbname]);
    
    while ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {
        $table = $row['TABLE_NAME'];
        if (!isset($tableColumns[$table])) {
            $tableColumns[$table] = [];
        }
        
        $tableColumns[$table][] = [
            'Field' => $row['COLUMN_NAME'],
            'Type' => $row['COLUMN_TYPE'],
            'Key' => $row['COLUMN_KEY'],
            'Null' => $row['IS_NULLABLE'],
            'Default' => $row['COLUMN_DEFAULT']
        ];
        
        $totalColumnCount++;
        
        // Track primary keys
        if ($row['COLUMN_KEY'] == 'PRI') {
            if (!isset($tablePrimaryKeys[$table])) {
                $tablePrimaryKeys[$table] = [];
            }
            $tablePrimaryKeys[$table][] = [
                'column' => $row['COLUMN_NAME'],
                'type' => $row['COLUMN_TYPE']
            ];
        }
    }
    
    $markdown .= "Total tables: $tableCount\n";
    $markdown .= "Total columns across all tables: $totalColumnCount\n\n";
    
    // Build comprehensive relationship analysis
    $markdown .= "## Relationships Between Tables\n\n";
    $markdown .= "| Source Table | Source Column | Target Table | Target Column | Relationship Type | Match % | Notes |\n";
    $markdown .= "|-------------|---------------|-------------|--------------|------------------|---------|-------|\n";
    
    $foundRelationships = [];
    $relationshipCount = 0;
    
    // PHASE 1: Look for formal foreign keys (most reliable)
    echo "<h2>Step 2/4: Checking formal foreign keys...</h2>";
    
    $fkQuery = "
        SELECT
            TABLE_NAME, COLUMN_NAME,
            REFERENCED_TABLE_NAME, REFERENCED_COLUMN_NAME,
            CONSTRAINT_NAME
        FROM
            INFORMATION_SCHEMA.KEY_COLUMN_USAGE
        WHERE
            REFERENCED_TABLE_NAME IS NOT NULL
            AND TABLE_SCHEMA = ?
    ";
    
    $stmt = $pdo->prepare($fkQuery);
    $stmt->execute([$dbname]);
    
    while ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {
        $relationshipCount++;
        $fromTable = $row['TABLE_NAME'];
        $fromColumn = $row['COLUMN_NAME'];
        $toTable = $row['REFERENCED_TABLE_NAME'];
        $toColumn = $row['REFERENCED_COLUMN_NAME'];
        $constraintName = $row['CONSTRAINT_NAME'];
        
        $relationType = "Formal Foreign Key";
        $matchPercentage = 100; // Formal FKs should be 100% by definition
        
        $markdown .= "| $fromTable | $fromColumn | $toTable | $toColumn | $relationType | $matchPercentage% | Constraint: $constraintName |\n";
        
        $foundRelationships["$fromTable.$fromColumn -> $toTable.$toColumn"] = true;
    }
    
    // PHASE 2: Look for naming pattern matches (with pre-filtering)
    echo "<h2>Step 3/4: Checking naming patterns...</h2>";
    
    // Precompute possible relationships based on naming conventions
    $potentialRelationships = [];
    
    foreach ($allTables as $fromTable) {
        foreach ($tableColumns[$fromTable] as $column) {
            $columnName = $column['Field'];
            
            // Skip primary keys as source
            if ($column['Key'] == 'PRI') {
                continue;
            }
            
            // For common ID columns, check all tables with matching PK name
            if (in_array($columnName, $commonIdColumns)) {
                foreach ($tablePrimaryKeys as $toTable => $primaryKeys) {
                    if ($fromTable == $toTable) continue; // Skip self
                    
                    foreach ($primaryKeys as $primaryKey) {
                        if ($primaryKey['column'] == $columnName) {
                            $potentialRelationships[] = [
                                'fromTable' => $fromTable,
                                'fromColumn' => $columnName,
                                'toTable' => $toTable,
                                'toColumn' => $primaryKey['column'],
                                'reason' => 'Common ID pattern',
                                'fromType' => $column['Type'],
                                'toType' => $primaryKey['type']
                            ];
                        }
                    }
                }
            }
            
            // Column name contains table name
            foreach ($allTables as $toTable) {
                if ($fromTable == $toTable) continue; // Skip self
                
                // Don't check all tables against all columns - use some filtering
                // Skip unlikely matches to improve performance
                if (strlen($toTable) < 3) continue; // Skip very short table names
                
                $pattern1 = '/^' . preg_quote($toTable, '/') . '(?:_id|id|_objid|_obj_id)$/i';
                $pattern2 = '/^' . preg_quote($toTable, '/') . '_/i';
                
                if (preg_match($pattern1, $columnName) || preg_match($pattern2, $columnName)) {
                    if (!isset($tablePrimaryKeys[$toTable]) || empty($tablePrimaryKeys[$toTable])) {
                        continue; // Skip if target table has no PK
                    }
                    
                    $targetPrimaryKey = $tablePrimaryKeys[$toTable][0]; // Use first PK
                    
                    $potentialRelationships[] = [
                        'fromTable' => $fromTable,
                        'fromColumn' => $columnName,
                        'toTable' => $toTable,
                        'toColumn' => $targetPrimaryKey['column'],
                        'reason' => 'Name pattern match',
                        'fromType' => $column['Type'],
                        'toType' => $targetPrimaryKey['type']
                    ];
                }
            }
        }
    }
    
    // Now we have a filtered list of potential relationships to validate
    $validationCount = 0;
    $totalPotential = count($potentialRelationships);
    
    foreach ($potentialRelationships as $rel) {
        $validationCount++;
        if ($validationCount % 50 == 0) {
            echo "<p>Validating relationship $validationCount of $totalPotential...</p>";
            flush();
        }
        
        $fromTable = $rel['fromTable'];
        $fromColumn = $rel['fromColumn'];
        $toTable = $rel['toTable'];
        $toColumn = $rel['toColumn'];
        $reason = $rel['reason'];
        
        // Skip if already found
        $relationshipKey = "$fromTable.$fromColumn -> $toTable.$toColumn";
        if (isset($foundRelationships[$relationshipKey])) {
            continue;
        }
        
        // Check type compatibility
        $fromType = strtolower(preg_replace('/\(\d+\)/', '', $rel['fromType']));
        $toType = strtolower(preg_replace('/\(\d+\)/', '', $rel['toType']));
        
        $typeCompatible = false;
        if (strpos($fromType, 'int') !== false && strpos($toType, 'int') !== false) {
            $typeCompatible = true; // Both integer types
        } else if ($fromType == $toType) {
            $typeCompatible = true; // Same types
        }
        
        if (!$typeCompatible) {
            continue; // Skip incompatible types
        }
        
        // Analyze the data match
        try {
            // Check if we have data to validate
            $fromCount = $pdo->query("SELECT COUNT(*) FROM `$fromTable` WHERE `$fromColumn` IS NOT NULL LIMIT 1")->fetchColumn();
            $toCount = $pdo->query("SELECT COUNT(*) FROM `$toTable` WHERE `$toColumn` IS NOT NULL LIMIT 1")->fetchColumn();
            
            if ($fromCount == 0 || $toCount == 0) {
                // No data to validate - use pattern match as only indicator
                $relationshipCount++;
                $markdown .= "| $fromTable | $fromColumn | $toTable | $toColumn | Unknown | N/A | $reason (no data) |\n";
                $foundRelationships[$relationshipKey] = true;
                continue;
            }
            
            // Fast check - sample a single value to see if it exists in target
            $sampleValue = $pdo->query("SELECT `$fromColumn` FROM `$fromTable` WHERE `$fromColumn` IS NOT NULL LIMIT 1")->fetchColumn();
            
            if ($sampleValue) {
                $check = $pdo->prepare("SELECT COUNT(*) FROM `$toTable` WHERE `$toColumn` = ?");
                $check->execute([$sampleValue]);
                $matches = $check->fetchColumn();
                
                if ($matches > 0) {
                    // We have a match - do full integrity check if table isn't too large
                    $isLargeTable = $fromCount > 10000;
                    
                    if ($isLargeTable) {
                        // For large tables, just sample more values
                        $sampleQuery = "SELECT `$fromColumn` FROM `$fromTable` 
                                       WHERE `$fromColumn` IS NOT NULL 
                                       LIMIT 20";
                        $sampleValues = $pdo->query($sampleQuery)->fetchAll(PDO::FETCH_COLUMN);
                        
                        if (!empty($sampleValues)) {
                            $placeholders = implode(',', array_fill(0, count($sampleValues), '?'));
                            $check = $pdo->prepare("SELECT COUNT(*) FROM `$toTable` WHERE `$toColumn` IN ($placeholders)");
                            $check->execute($sampleValues);
                            $sampleMatches = $check->fetchColumn();
                            
                            $sampleMatchPercentage = round(($sampleMatches / count($sampleValues)) * 100);
                            
                            // If we have a good sample match, add it
                            if ($sampleMatchPercentage > 30) {
                                $relationshipCount++;
                                $relationType = "Sampled ($sampleMatchPercentage% of 20)";
                                $markdown .= "| $fromTable | $fromColumn | $toTable | $toColumn | $relationType | ~$sampleMatchPercentage% | $reason (large table) |\n";
                                $foundRelationships[$relationshipKey] = true;
                            }
                        }
                    } else {
                        // For smaller tables, do full analysis
                        $matchPercentage = analyzeIntegrity($pdo, $fromTable, $fromColumn, $toTable, $toColumn);
                        if ($matchPercentage > 30) {
                            $relationshipCount++;
                            $relationType = determineRelationshipType($pdo, $fromTable, $fromColumn, $toTable, $toColumn, $matchPercentage);
                            $markdown .= "| $fromTable | $fromColumn | $toTable | $toColumn | $relationType | $matchPercentage% | $reason |\n";
                            $foundRelationships[$relationshipKey] = true;
                        }
                    }
                }
            }
        } catch (Exception $e) {
            // Skip errors in validation
            continue;
        }
    }
    
    // PHASE 3: Targeted data-driven detection for specific tables
    echo "<h2>Step 4/4: Finalizing report...</h2>";
    
    $markdown .= "\n\nFound $relationshipCount potential relationships between tables.\n\n";
    
    // Add table counts to Markdown
    $markdown .= "## Table Details\n\n";
    $markdown .= "| Table Name | Row Count | Column Count | Has Primary Key |\n";
    $markdown .= "|------------|-----------|-------------|-----------------|\n";
    
    // Add details for each table (with optimized row counting)
    foreach ($allTables as $table) {
        try {
            $rowCount = $pdo->query("SELECT COUNT(*) FROM `$table`")->fetchColumn();
            $colCount = count($tableColumns[$table]);
            $hasPK = isset($tablePrimaryKeys[$table]) ? "Yes" : "No";
            $markdown .= "| $table | " . number_format($rowCount) . " | $colCount | $hasPK |\n";
        } catch (Exception $e) {
            $markdown .= "| $table | Error | " . count($tableColumns[$table]) . " | ? |\n";
        }
    }
    
    // Calculate execution time
    $endTime = microtime(true);
    $executionTime = round($endTime - $startTime, 2);
    $markdown .= "\n\n*Analysis completed in $executionTime seconds.*\n";
    
    // Write Markdown to file
    $outfile = 'lineage_complete_relationships.md';
    file_put_contents($outfile, $markdown);
    
    echo "<h1>LineageDB Complete Relationship Analysis</h1>";
    echo "<p>Database: $dbname</p>";
    echo "<p>Found $tableCount tables</p>";
    echo "<p>Identified $relationshipCount potential relationships</p>";
    echo "<p>Complete markdown file has been saved to: <code>$outfile</code></p>";
    echo "<p>Execution time: $executionTime seconds</p>";
    echo "<p>You can upload this file to your GitHub repository.</p>";
    
} catch (PDOException $e) {
    echo "<h2>Database Connection Error</h2>";
    echo "<p>Error: " . $e->getMessage() . "</p>";
}

// Function to analyze referential integrity (optimized)
function analyzeIntegrity($pdo, $fromTable, $fromColumn, $toTable, $toColumn) {
    try {
        // Count non-null values in source column
        $nonNullCount = $pdo->query("SELECT COUNT(*) FROM `$fromTable` WHERE `$fromColumn` IS NOT NULL")->fetchColumn();
        
        if ($nonNullCount == 0) {
            return 0; // No data to analyze
        }
        
        // Check if the table is too large for full validation
        if ($nonNullCount > 5000) {
            // Sample up to 5000 records
            $sampleQuery = "SELECT `$fromColumn` FROM `$fromTable` 
                           WHERE `$fromColumn` IS NOT NULL 
                           LIMIT 5000";
            $sample = $pdo->query($sampleQuery)->fetchAll(PDO::FETCH_COLUMN);
            
            // Get unique values from sample
            $uniqueValues = array_unique($sample);
            $chunks = array_chunk($uniqueValues, 500); // Process in chunks of 500
            
            $validMatches = 0;
            foreach ($chunks as $chunk) {
                $placeholders = implode(',', array_fill(0, count($chunk), '?'));
                $checkQuery = "SELECT COUNT(DISTINCT `$fromColumn`) 
                              FROM `$fromTable` 
                              WHERE `$fromColumn` IN ($placeholders) 
                              AND `$fromColumn` IN (SELECT `$toColumn` FROM `$toTable`)";
                
                $stmt = $pdo->prepare($checkQuery);
                $stmt->execute($chunk);
                $validMatches += $stmt->fetchColumn();
            }
            
            return round(($validMatches / count($uniqueValues)) * 100);
        } else {
            // For smaller tables, do a direct query
            $validRefs = $pdo->query("
                SELECT COUNT(*) FROM `$fromTable`
                WHERE `$fromColumn` IS NOT NULL
                AND `$fromColumn` IN (SELECT `$toColumn` FROM `$toTable`)
            ")->fetchColumn();
            
            return round(($validRefs / $nonNullCount) * 100);
        }
    } catch (Exception $e) {
        return 0;
    }
}

// Function to determine relationship type (simplified)
function determineRelationshipType($pdo, $fromTable, $fromColumn, $toTable, $toColumn, $integrity) {
    try {
        // If integrity is too low, it's a weak relationship
        if ($integrity < 30) {
            return "Weak";
        }
        
        // Check if foreign key column is unique
        $fromUnique = false;
        $result = $pdo->query("SHOW INDEXES FROM `$fromTable` WHERE Column_name = '$fromColumn'");
        while ($row = $result->fetch(PDO::FETCH_ASSOC)) {
            if ($row['Non_unique'] == 0) {
                $fromUnique = true;
                break;
            }
        }
        
        // If the foreign key is unique and integrity is high
        if ($fromUnique && $integrity > 80) {
            return "One-to-One";
        }
        
        // Count distinct values (limit to avoid performance issues)
        $distinctValuesQuery = "SELECT COUNT(DISTINCT `$fromColumn`) FROM 
                               (SELECT `$fromColumn` FROM `$fromTable` 
                                WHERE `$fromColumn` IS NOT NULL 
                                LIMIT 1000) as sample";
        $distinctValues = $pdo->query($distinctValuesQuery)->fetchColumn();
        
        // Count rows in target table
        $targetRows = $pdo->query("SELECT COUNT(*) FROM `$toTable` LIMIT 1000")->fetchColumn();
        
        if ($distinctValues > 0 && $targetRows > 0) {
            $ratio = $distinctValues / $targetRows;
            
            if ($ratio > 0.7) {
                return "Many-to-One";
            } else if ($ratio < 0.3) {
                return "One-to-Many";
            } else {
                return "Mixed";
            }
        }
        
        return "One-to-Many"; // Default
    } catch (Exception $e) {
        return "Unknown";
    }
}
?>